-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Data structures and algorithms
--   
--   Data structures and algorithms for competitive programming in Haskell
@package haccepted
@version 0.1.0.0


-- | <h2>Aho-Corasick algorithm</h2>
--   
--   The Aho-Corasick algorithm builds an automaton from a set of pattern
--   strings, and then uses it to find positions in a search string where
--   each of the pattern strings occur.
--   
--   This implementation only works on ByteStrings, to keep things fast. If
--   required it can be adapted to work on Strings, or even more generally
--   (Ord a, Foldable f) =&gt; f a.
--   
--   A TrieAC a can be constructed from pattern strings with associated
--   values a, which can be then be turned into an ACRoot a. An ACRoot a
--   can then be run on a search string to find matches. Construction and
--   matching are both lazy.
--   
--   Sources:
--   
--   <ul>
--   <li>Alfred V. Aho and Margaret J. Corasick, "Efficient string
--   matching: An aid to bibliographic search", 1975
--   <a>https://dl.acm.org/doi/10.1145/360825.360855</a></li>
--   <li>Stanford CS166 Aho-Corasick lecture slides
--   <a>https://web.stanford.edu/class/archive/cs/cs166/cs166.1166/lectures/04/Slides04.pdf</a></li>
--   </ul>
--   
--   Let k be the alphabet size. Let the complexity of IntMap operations be
--   f(n), where n is the size of the map. f(n) is O(min(n, word size)),
--   see IntMap documentation for details.
module AhoCorasick
data TrieAC a

-- | An empty trie.
emptyTAC :: TrieAC a

-- | Inserts a string with an associated value into a trie. O(n * f(k))
--   where n is the length of the string.
insertTAC :: ByteString -> a -> TrieAC a -> TrieAC a

-- | Builds a trie from a list of strings and associated values. O(n *
--   f(k)) where n is total length of the strings.
fromListTAC :: [(ByteString, a)] -> TrieAC a
data ACRoot a

-- | Builds an Aho-Corasick automaton from a trie. O(n), where n is the
--   number of nodes in the trie. This is not more than the total length of
--   strings the trie was constructed with.
fromTrieAC :: TrieAC a -> ACRoot a

-- | Returns a list of length (m + 1) where m is the length of the search
--   string. This list contains a list of pattern matches for every
--   position in the string, including before the first character. A match
--   at a position is present as the associated value of the pattern string
--   found to be ending at that position. O(m * f(k) + z), where m is the
--   length of the string and z is the total number of matches.
matchAC :: ACRoot a -> ByteString -> [[a]]
instance GHC.Show.Show a => GHC.Show.Show (AhoCorasick.TrieAC a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (AhoCorasick.ACRoot a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (AhoCorasick.ACNode a)


-- | <h2>Binary search</h2>
--   
--   Sources:
--   
--   <ul>
--   
--   <li><a>https://en.wikipedia.org/wiki/Binary_search_algorithm#Procedure_for_finding_the_leftmost_element</a></li>
--   </ul>
--   
--   The complexities below assume the predicate takes O(1) time, they
--   should be scaled appropriately if not so.
module BinSearch

-- | Returns the first value in [l..h] which satisfies the predicate f, h +
--   1 otherwise. Returns l if l &gt; h. l + h should not overflow. O(log
--   (h - l + 1)).
binSearch :: Integral i => (i -> Bool) -> i -> i -> i

-- | binSearch on an Array. O(log n).
binSearchA :: (a -> Bool) -> Array Int a -> Int

-- | binSearch but the predicate returns a monad. O(log (h - l + 1)).
binSearchM :: (Monad m, Integral i) => (i -> m Bool) -> i -> i -> m i


-- | <h2>Disjoint set union</h2>
--   
--   Data structure to maintain disjoint sets of Ints, supporting find and
--   union. Uses union by size and path halving.
--   
--   Sources:
--   
--   <ul>
--   
--   <li><a>https://en.wikipedia.org/wiki/Disjoint-set_data_structure</a></li>
--   
--   <li><a>https://cp-algorithms.com/data_structures/disjoint_set_union.html</a></li>
--   
--   <li><a>https://github.com/kth-competitive-programming/kactl/blob/main/content/data-structures/UnionFind.h</a></li>
--   <li>Robert E. Tarjan and Jan van Leeuwen, "Worst-Case Analysis of Set
--   Union Algorithms", 1984
--   <a>https://dl.acm.org/doi/10.1145/62.2160</a></li>
--   </ul>
--   
--   Use unboxed arrays (IOUArray/STUArray) for best performance! n = r - l
--   + 1 in all instances below. α is the inverse Ackermann function.
module DSU

-- | Creates a new DSU structure with elements in the range (l, r), each in
--   its own set. O(n).
newD :: MArray a Int m => (Int, Int) -> m (a Int Int)

-- | Returns whether the two elements are in the same set. Amortized
--   O(α(n)).
sameSetD :: MArray a Int m => a Int Int -> Int -> Int -> m Bool

-- | Unites the sets containing the two elements. If they are already in
--   the same set, returns False, otherwise performs the union and returns
--   True. Amortized O(α(n)).
unionD :: MArray a Int m => a Int Int -> Int -> Int -> m Bool


-- | <h2>Simple utilities for 2D geometry</h2>
module Geometry
data V2
V2 :: !Int -> !Int -> V2

-- | The square of the magnitude of the vector.
mag2 :: V2 -> Int

-- | The square of the distance between two vectors.
dist2 :: V2 -> V2 -> Int

-- | Dot product of two vectors.
dot :: V2 -> V2 -> Int

-- | Cross product of two vectors.
cross :: V2 -> V2 -> Int

-- | The turn going from p1 to p2 to p3. Returns an Ordering representing
--   left, no turn, or right. Mnemonic: LT stands for "left turn".
turn :: V2 -> V2 -> V2 -> Ordering
instance GHC.Show.Show Geometry.V2
instance GHC.Classes.Ord Geometry.V2
instance GHC.Classes.Eq Geometry.V2
instance GHC.Num.Num Geometry.V2
instance Control.DeepSeq.NFData Geometry.V2


-- | <h2>2D convex hull</h2>
--   
--   The convex hull is calculated using Andrew's monotone chain algorithm.
--   
--   Sources:
--   
--   <ul>
--   <li><a>https://cp-algorithms.com/geometry/convex-hull.html</a></li>
--   <li>R. L. Graham, "An Efficient Algorithm for Determining the Convex
--   Hull of a Finite Planar Set", 1972
--   <a>https://www.math.ucsd.edu/~ronspubs/72_10_convex_hull.pdf</a></li>
--   <li>A. M. Andrew, "Another efficient algorithm for convex hulls in two
--   dimensions", 1979
--   <a>https://www.sciencedirect.com/science/article/abs/pii/0020019079900723</a></li>
--   </ul>
module ConvexHull

-- | Calculates the convex hull for a set of points. The points should be
--   distinct. The points on the hull are returned in clockwise order. O(n
--   log n).
convexHull :: [V2] -> [V2]


-- | <h2>Knuth-Morris-Pratt algorithm</h2>
--   
--   A string matching algorithm that generates a prefix function p from an
--   input string s, where p(i) is the length of the longest prefix of s
--   that ends at index i, excluding the prefix [0..i].
--   
--   Sources:
--   
--   <ul>
--   
--   <li><a>https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm</a></li>
--   <li><a>https://cp-algorithms.com/string/prefix-function.html</a></li>
--   </ul>
module KMP

-- | Constructs the prefix function. The input sequence should be
--   0-indexed. O(n).
prefixFunc :: Eq a => Int -> (Int -> a) -> UArray Int Int

-- | prefixFunc for a ByteString. O(n).
prefixFuncBS :: ByteString -> UArray Int Int


-- | <h2>Edge-labeled/weighted graphs</h2>
--   
--   There are useful definitions and algorithms in Data.Tree and
--   Data.Graph but sadly these only deal with unlabeled graphs. Most
--   definitions here mirror those in Data.Graph.
module LabelledGraph
type LEdge b = (Vertex, (b, Vertex))
type LGraph b = Array Vertex [(b, Vertex)]
data LTree b a
LNode :: a -> [(b, LTree b a)] -> LTree b a
[rootLabelL] :: LTree b a -> a
[subForestL] :: LTree b a -> [(b, LTree b a)]

-- | Builds a LGraph from a list of LEdges. O(n + m) for bounds size n and
--   m edges.
buildLG :: Bounds -> [LEdge b] -> LGraph b

-- | For a LGraph that is known to be a tree, returns its LTree
--   representation. O(n).
dfsLTree :: LGraph b -> Vertex -> LTree b Vertex

-- | Drops labels from an LTree. O(n).
lTreeToTree :: LTree b a -> Tree a
instance Data.Traversable.Traversable (LabelledGraph.LTree b)
instance Data.Foldable.Foldable (LabelledGraph.LTree b)
instance GHC.Base.Functor (LabelledGraph.LTree b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (LabelledGraph.LTree b a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (LabelledGraph.LTree b a)
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData b) => Control.DeepSeq.NFData (LabelledGraph.LTree b a)


-- | <h2>Dijkstra's algorithm</h2>
--   
--   An algorithm to find multi-source shortest paths in a graph with
--   non-negative edges.
--   
--   There are a variety of possible implementations depending on what is
--   required, such as finding parents, early stopping, etc. This is a
--   basic implementation calculating only the distances, to be modified
--   when required.
--   
--   Sources:
--   
--   <ul>
--   <li>Edgar W. Dijkstra, "A note on two problems in connexion with
--   graphs", 1959
--   <a>https://www-m3.ma.tum.de/foswiki/pub/MN0506/WebHome/dijkstra.pdf</a></li>
--   <li>Implementation is folklore</li>
--   </ul>
module Dijkstra

-- | Runs Dijkstra's algorithm on the given graph. Unreachable vertices
--   have distance maxBound. O((V + E) log V).
dijkstra :: LGraph Weight -> [Vertex] -> UArray Vertex Weight

-- | Runs Dijkstra's algorithm on the given graph. srcs should not have
--   duplicates. Unreachable vertices have distance maxBound. Faster than
--   dijkstra, especially for large sparse graphs. O((V + E) log E).
dijkstraH :: LGraph Weight -> [Vertex] -> UArray Vertex Weight
type Weight = Int


-- | <h2>Modular arithmetic</h2>
--   
--   MInt is a newtype of Int for arithmetic modulo a known fixed prime.
--   For a more general type see Mod.hs.
--   
--   Instances of Eq, Num, Fractional exist for MInt. All the usual
--   operations take O(1) time, except for recip which takes O(log m) time.
--   An instance of Enum exists for MInt. The enum is cyclic, it wraps to 0
--   after m-1. An instance of IArray UArray MInt exists. Instances of
--   MArray (STUArray s) MInt (ST s) and MArray IOUArray MInt IO are also
--   defined.
module MInt

-- | Int type for arithmetic modulo a fixed prime mm.
newtype MInt
MInt :: Int -> MInt
[unMInt] :: MInt -> Int

-- | The prime modulus.
mm :: Int
instance GHC.Show.Show MInt.MInt
instance GHC.Classes.Ord MInt.MInt
instance GHC.Classes.Eq MInt.MInt
instance GHC.Num.Num MInt.MInt
instance GHC.Real.Fractional MInt.MInt
instance GHC.Enum.Enum MInt.MInt
instance Data.Array.Base.IArray Data.Array.Base.UArray MInt.MInt
instance Data.Array.Base.MArray (Data.Array.Base.STUArray s) MInt.MInt (GHC.ST.ST s)
instance Data.Array.Base.MArray Data.Array.IO.Internals.IOUArray MInt.MInt GHC.Types.IO
instance Control.DeepSeq.NFData MInt.MInt


-- | <h2>Math</h2>
--   
--   Sources:
--   
--   <ul>
--   
--   <li><a>https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm</a></li>
--   </ul>
module Math

-- | Returns (g, s) where g = gcd(a, b); as + bt = g. O(log min(a, b)).
--   Also see note for egcd2.
egcd :: Integral i => i -> i -> (i, i)

-- | Returns (g, s, t) where g = gcd(a, b); as + bt = g. O(log min(a, b)).
--   Note: If the inputs are negative the returned gcd may be negative. abs
--   the inputs or sign flip the outputs if this is undesirable. The
--   complexity assumes operations quotRem, (-), (*), (==0) all take O(1).
egcd2 :: Integral i => i -> i -> (i, i, i)


-- | <h2>Miscellaneous functions/recipes</h2>
module Misc

-- | Generates distinct pairs of elements from a list. O(n^2).
pairs :: [a] -> [(a, a)]

-- | Generates an Array from bounds and a function. O(n) assuming f takes
--   O(1).
fArray :: (IArray a e, Ix i) => (i, i) -> (i -> e) -> a i e

-- | Splits a list into chunks of fixed size. O(n).
chunksOf :: Int -> [a] -> [[a]]

-- | Replicates a list n times. O(nm) where m is the length of the list.
replicateL :: Int -> [a] -> [a]

-- | Eliminates consecutive duplicate elements. O(n).
unique :: Eq a => [a] -> [a]

-- | Folds a list of values such that the ith element of the result
--   contains the folded result of all elements in the input list excluding
--   the ith element. The fold is strict. The elements get folded in a
--   not-very-simple order, so the following should hold: (b <tt>f</tt> a1)
--   <tt>f</tt> a2 = (b <tt>f</tt> a2) <tt>f</tt> a1 O(n log n) assuming f
--   takes O(1).
foldExclusive :: (b -> a -> b) -> b -> [a] -> [b]

-- | Modifies an element in a mutable array.
modifyArray :: (MArray a e m, Ix i) => a i e -> i -> (e -> e) -> m ()

-- | Modifies an element in a mutable array. Strict version.
modifyArray' :: (MArray a e m, Ix i) => a i e -> i -> (e -> e) -> m ()

-- | Compose a strict left fold function with a mapM function. Useful for
--   foldMs. foldM (f <a>foldMComp</a> g) z = fmap (foldl' f z) . mapM g
foldMComp :: Monad m => (b -> a -> b) -> (c -> m a) -> b -> c -> m b

-- | Repeatedly applies a function to a value and returns the value which
--   gives back Nothing.
farthest :: (a -> Maybe a) -> a -> a

-- | Folds a tree. This does the same job as Data.Tree.foldTree but with
--   different fold functions, which may be preferable in cases such as CPS
--   folds.
foldTree' :: (a -> b -> c) -> (c -> b -> b) -> b -> Tree a -> c

-- | A semigroup where the operation (&lt;&gt;) is commutative. a &lt;&gt;
--   b = b &lt;&gt; a
class Semigroup a => Commutative a

-- | A monoid where elements have inverses. a &lt;&gt; invert a = mempty
--   invert a &lt;&gt; a = mempty
class Monoid a => Group a
invert :: Group a => a -> a

-- | A semigroup where the elements are idempotent. a &lt;&gt; a = a
class Semigroup a => Idempotent a

-- | Returns the number of bits required to represent the value.
bitLength :: FiniteBits b => b -> Int

-- | The elements at odd positions of a list.
odds :: [a] -> [a]

-- | The elements at even positions of a list.
evens :: [a] -> [a]

-- | Short-circuiting monadic ||.
orM :: Monad m => m Bool -> m Bool -> m Bool

-- | Short-circuiting monadic &amp;&amp;.
andM :: Monad m => m Bool -> m Bool -> m Bool

-- | Monadic version of any.
anyM :: (Monad m, Foldable f) => (a -> m Bool) -> f a -> m Bool

-- | Monadic version of all.
allM :: (Monad m, Foldable f) => (a -> m Bool) -> f a -> m Bool
instance GHC.Classes.Ord a => Misc.Idempotent (Data.Semigroup.Max a)
instance GHC.Classes.Ord a => Misc.Idempotent (Data.Semigroup.Min a)
instance Misc.Idempotent (Data.Semigroup.First a)
instance Misc.Idempotent (Data.Semigroup.Last a)
instance GHC.Num.Num a => Misc.Group (Data.Semigroup.Internal.Sum a)
instance GHC.Num.Num a => Misc.Commutative (Data.Semigroup.Internal.Sum a)


-- | <h2>Floyd-Warshall algorithm</h2>
--   
--   Finds shortest paths between all pairs of vertices in a directed
--   weighted graph.
--   
--   Sources:
--   
--   <ul>
--   
--   <li><a>https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm</a></li>
--   <li>Robert W. Floyd, "Algorithm 97: Shortest Path", Communications of
--   the ACM, Vol. 5, No. 6, 1962
--   <a>https://dl.acm.org/doi/10.1145/367766.368168</a></li>
--   </ul>
module FloydWarshall
data WEdge
WEdge :: !Vertex -> !Vertex -> !Weight -> WEdge
type Weight = Int

-- | Runs the algorithm on the graph represented by the given list of
--   edges. There should be no negative cycles. O(|V|^3). Queries take
--   O(1).
floydWarshallFromEdges :: Bounds -> [WEdge] -> Vertex -> Vertex -> Maybe Weight

-- | Runs the algorithm on the adjacency matrix of the graph given as a
--   mutable array. O(|V|^3).
floydWarshall :: MArray a Weight m => a (Vertex, Vertex) Weight -> m ()
instance GHC.Show.Show FloydWarshall.WEdge
instance GHC.Classes.Eq FloydWarshall.WEdge


-- | <h2>Fenwick tree, or binary indexed tree</h2>
--   
--   A data structure supporting point updates and range queries, or the
--   opposite. Large ranges, beyond typical memory limits, are supported.
--   
--   Sources:
--   
--   <ul>
--   <li><a>https://en.wikipedia.org/wiki/Fenwick_tree</a></li>
--   <li>Peter M. Fenwick, "A New Data Structure for Cumulative Frequency
--   Tables", 1994
--   <a>https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.8917</a></li>
--   
--   <li><a>https://hackage.haskell.org/package/binary-indexed-tree</a></li>
--   </ul>
--   
--   4 / / 2 6 <i> </i> 1 3 5 7
--   
--   Let n = r - l + 1 where (l, r) is the range of the Fenwick tree. The
--   complexities assume (&lt;&gt;) takes O(1) time.
module Fenwick
data FTree a

-- | Builds a Fenwick tree on range (l, r) where each element is mempty.
--   O(log n).
emptyF :: Monoid a => (Int, Int) -> FTree a

-- | Builds a Fenwick tree on (l, r) where the elements are taken from a
--   list. If the list is shorter than the range, the remaining elements
--   are mempty. O(n).
fromListF :: Monoid a => (Int, Int) -> [a] -> FTree a

-- | The bounds of the Fenwick tree. O(1).
boundsF :: FTree a -> (Int, Int)

-- | mappends to the element at an index. O(log n).
mappendF :: Commutative a => Int -> a -> FTree a -> FTree a

-- | The result of folding the prefix upto the given index. Indices outside
--   the tree range are allowed, it is assumed elements there are mempty.
--   O(log n).
foldPrefixF :: Monoid a => Int -> FTree a -> a

-- | Folds the elements in the range (l, r). O(log n).
foldRangeF :: (Commutative a, Group a) => Int -> Int -> FTree a -> a

-- | mappends to all elements in the range (l, r). Can be used with
--   foldPrefixF for point queries. O(log n).
mappendRangeF :: (Commutative a, Group a) => Int -> Int -> a -> FTree a -> FTree a

-- | Binary searches for the shortest prefix such that the fold of all
--   values in it satisfies the given monotonic predicate. Returns the end
--   index and the fold of the found prefix. O(log n).
binSearchF :: Monoid a => (a -> Bool) -> FTree a -> Maybe (Int, a)

-- | Converts to a list of prefix accumulated values. O(n).
toScanl1F :: Monoid a => FTree a -> [a]
instance GHC.Show.Show a => GHC.Show.Show (Fenwick.FNode a)
instance GHC.Show.Show a => GHC.Show.Show (Fenwick.FTree a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Fenwick.FTree a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Fenwick.FNode a)


-- | <h2>Dinic's algorithm, or Dinitz's algorithm</h2>
--   
--   An algorithm to find the maximum flow in a flow network.
--   
--   Sources:
--   
--   <ul>
--   <li>Y. Dinitz, "Dinitz' Algorithm: The Original Version and Even's
--   Version", 2006
--   <a>https://www.cs.bgu.ac.il/~dinitz/Papers/Dinitz_alg.pdf</a></li>
--   <li>AC Library
--   <a>https://github.com/atcoder/ac-library/blob/master/atcoder/maxflow.hpp</a></li>
--   </ul>
module Dinic
data FlowEdge
FlowEdge :: !Vertex -> !Vertex -> !Flow -> FlowEdge
[from_] :: FlowEdge -> !Vertex
[to_] :: FlowEdge -> !Vertex
[cap_] :: FlowEdge -> !Flow
data FlowResult
FlowResult :: !Flow -> [Flow] -> [Bool] -> FlowResult
[getFlow] :: FlowResult -> !Flow
[getFlows] :: FlowResult -> [Flow]
[getMinCut] :: FlowResult -> [Bool]
data ToEdge
ToEdge :: !Vertex -> !EdgeIndex -> ToEdge
[to__] :: ToEdge -> !Vertex
[edgeIndex_] :: ToEdge -> !EdgeIndex
type Flow = Int
type EdgeIndex = Int

-- | Runs Dinic's algorithm on the graph made up of the given FlowEdges.
--   Returns a FlowResult, describing a max flow configuration with 1. the
--   max flow value 2. flow values of the edges in the order in which they
--   were given 3. a list of Bools for each edge indicating whether the
--   edge is in a min-cut O(V^2 E) in the general case. O(min(V^(2<i>3),
--   E^(1</i>2)) E) for unit capacity graphs. O(V^(1/2) E) for unit
--   networks, such as in maximum bipartite matching.
dinic :: Bounds -> [FlowEdge] -> Vertex -> Vertex -> FlowResult
instance GHC.Show.Show Dinic.FlowEdge
instance GHC.Classes.Eq Dinic.FlowEdge
instance Control.DeepSeq.NFData Dinic.FlowEdge


-- | <h2>Centroid decomposition</h2>
--   
--   A recursive decomposition (divide-and-conquer) of a tree into multiple
--   subtrees. This allows performing certain operations involving paths on
--   the original tree effectively, by taking every path on the tree into
--   account exactly once when it passes through the root of a decomposed
--   subtree. The roots of the subtrees are chosen to be centroids so that
--   the recursive decomposition has logarithmic depth.
--   
--   Sources:
--   
--   <ul>
--   
--   <li><a>https://petr-mitrichev.blogspot.com/2015/03/this-week-in-competitive-programming_22.html</a></li>
--   
--   <li><a>https://github.com/cheran-senthil/PyRival/blob/master/pyrival/graphs/centroid_decomposition.py</a></li>
--   </ul>
module CentroidDecomp

-- | Performs centroid decomposition on a tree of n nodes, returning the
--   decomposition as a tree of n trees. O(n log n).
centroidDecompose :: Tree a -> Tree (Tree a)

-- | Same as centroidDecompose, for edge-labelled graphs. O(n log n).
centroidDecomposeL :: LTree b a -> Tree (LTree b a)


-- | <h2>Breadth first search</h2>
--   
--   Sources:
--   
--   <ul>
--   <li><a>https://en.wikipedia.org/wiki/Breadth-first_search</a></li>
--   </ul>
module BFS

-- | BFS on a graph, starting from the given source vertices. One tree per
--   source is returned, which contains all the vertices reached from the
--   source before they could be reached by another. Note that this is
--   unlike Data.Graph.dfs, which returns one Tree for each connected
--   component. O(n + m), for a graph with n vertices and m edges.
bfs :: Graph -> [Vertex] -> Forest Vertex


-- | <h2>Mo's algorithm</h2>
--   
--   Useful for answering certain range queries on a static sequence. The
--   algorithm works by maintaining some state for a current range, and
--   updating the state by adding or removing elements one by one. An
--   important parameter for the algorithm is the block size. If the range
--   size is n, number of queries is q, block size is b, state update takes
--   time f(n), getting the answer for the current state takes g(n), then
--   the algorithm answers all queries in O(q log q + bq * f(n) + n^2/b *
--   f(n) + q * g(n)) A suitable value of block size minimizes run time.
--   For example, when q ~ n, f(n) = O(1), g(n) = O(1), setting b = sqrt(n)
--   gives run time O(n sqrt(n)). For f(n) = O(log n), a better choice of b
--   is sqrt(n/log n) giving run time O(n sqrt(n log n)). In practice, it
--   works to experiment a bit and choose a good fixed value.
--   
--   Sources:
--   
--   <ul>
--   
--   <li><a>https://cp-algorithms.com/data_structures/sqrt_decomposition.html</a></li>
--   </ul>
module Mo
data MoQuery
MoQuery :: !Int -> !Int -> !Tag -> MoQuery
[ql_] :: MoQuery -> !Int
[qr_] :: MoQuery -> !Int
[qtag_] :: MoQuery -> !Tag
type Tag = Int

-- | Run Mo's algorithm given the block size, state update and answer
--   functions, and queries. See above for time complexity.
runMo :: Monad m => Int -> (Int -> m ()) -> (Int -> m ()) -> m a -> [MoQuery] -> m [(Tag, a)]

-- | Square root of an Int, rounded to an Int. O(1).
sqrtSize :: Int -> Int
instance GHC.Show.Show Mo.MoQuery
instance Control.DeepSeq.NFData Mo.MoQuery


-- | <h2>Modular arithmetic</h2>
--   
--   Mod m i is an integer of type i modulo m. m will usually be a
--   compile-time constant. If m is not known at compile time, Mod can
--   still be used via GHC.TypeNats.SomeNat. m must be &gt;= 2 and fit in
--   the type i. Integer operations on i for values in [0..m-1] must not
--   overflow. Examples to avoid are using (-) with a word type or using
--   (*) with a large enough mod that (m-1)^2 oveflows.
--   
--   This is a very general type, for something simpler see MInt.hs.
--   
--   Instances of Eq, Num, Fractional exist for Mod m i. All the usual
--   operations take O(1) time, except for recip which takes O(log n) time.
--   This assumes Integral i methods take O(1) time. An instance of Enum
--   exists for MInt. The enum is cyclic, it wraps to 0 after m-1. An
--   instance of IArray UArray MInt exists. Instances of MArray (STUArray
--   s) MInt (ST s) and MArray IOUArray MInt IO are also defined.
--   
--   M7 Commonly used modulus.
--   
--   M3 Commonly used modulus.
module Mod

-- | Type for modular arithmetic modulo m with underlying type i.
newtype Mod (m :: Nat) i
Mod :: i -> Mod (m :: Nat) i
[unMod] :: Mod (m :: Nat) i -> i
type M7 = Mod 1000000007 Int
type M3 = Mod 998244353 Int

-- | The multiplicative inverse modulo m. It exists if and only if the
--   number is coprime to m. O(log n).
invMaybe :: forall m i. (KnownNat m, Integral i) => Mod m i -> Maybe (Mod m i)
instance GHC.Show.Show i => GHC.Show.Show (Mod.Mod m i)
instance GHC.Classes.Ord i => GHC.Classes.Ord (Mod.Mod m i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Mod.Mod m i)
instance (GHC.TypeNats.KnownNat m, GHC.Real.Integral i) => GHC.Num.Num (Mod.Mod m i)
instance (GHC.TypeNats.KnownNat m, GHC.Real.Integral i) => GHC.Real.Fractional (Mod.Mod m i)
instance (GHC.TypeNats.KnownNat m, GHC.Real.Integral i) => GHC.Enum.Enum (Mod.Mod m i)
instance Data.Array.Base.IArray Data.Array.Base.UArray e => Data.Array.Base.IArray Data.Array.Base.UArray (Mod.Mod m e)
instance Data.Array.Base.MArray (Data.Array.Base.STUArray s) e (GHC.ST.ST s) => Data.Array.Base.MArray (Data.Array.Base.STUArray s) (Mod.Mod m e) (GHC.ST.ST s)
instance Data.Array.Base.MArray Data.Array.IO.Internals.IOUArray e GHC.Types.IO => Data.Array.Base.MArray Data.Array.IO.Internals.IOUArray (Mod.Mod m e) GHC.Types.IO
instance Control.DeepSeq.NFData i => Control.DeepSeq.NFData (Mod.Mod m i)


-- | <h2>PQ-tree</h2>
--   
--   PQ-tree is a data structure for representing permutations. It's useful
--   for solving the consecutive ones problem.
--   
--   This is an implementation of PQ-tree as described by Booth and Lueker.
--   The tree consists of three types of nodes, P, Q and leaf. Leaves are
--   single elements. The frontier of the tree is the left to right order
--   of leaves in the tree. A P-node is equivalent to another with its
--   children permuted in any order. A Q-node is equivalent to one with its
--   children reversed. The permutations represented by a tree are the
--   frontiers of all equivalent trees.
--   
--   The various reduction templates described in Booth and Lueker's paper
--   are used, but the construction algorithm is not. This implementation
--   is purely functional, hence it uses a simpler top-down approach
--   instead that runs in O(n) time (plus set member check overheads)
--   rather than in O(update size). This implementation is specialized to
--   Ints, but can be modified to work with other types.
--   
--   Sources:
--   
--   <ul>
--   <li><a>https://en.wikipedia.org/wiki/PQ_tree</a></li>
--   <li>Kellogg S. Booth and George S. Lueker, "Testing for the
--   consecutive ones property, interval graphs, and graph planarity using
--   PQ-tree algorithms", 1976
--   <a>https://www.sciencedirect.com/science/article/pii/S0022000076800451</a></li>
--   </ul>
module PQTree
data PQNode

-- | Builds a PQ-tree from a set of Ints. O(n).
buildPQ :: [Int] -> PQNode

-- | Reduces a PQ-tree with a set of Ints. This should be a subset of what
--   it was constructed with. O(n).
reducePQ :: [Int] -> PQNode -> Maybe PQNode

-- | Reduces a PQ-tree with many sets. O(mn) for m sets.
reduceAllPQ :: [[Int]] -> PQNode -> Maybe PQNode

-- | The frontier of the PQ-tree. O(n).
frontierPQ :: PQNode -> [Int]

-- | The permutations represented by the PQ-tree. O(do not use).
permsPQ :: PQNode -> [[Int]]
instance GHC.Show.Show PQTree.PQNode
instance GHC.Show.Show PQTree.RNode
instance Control.DeepSeq.NFData PQTree.PQNode


-- | <h2>Prufer sequences</h2>
--   
--   Functions to convert trees to Prufer sequences and vice versa
--   
--   Sources:
--   
--   <ul>
--   <li><a>https://en.wikipedia.org/wiki/Pr%C3%BCfer_sequence</a></li>
--   <li>Xiaodong Wang, Lei Wang, Yingjie Wu, "An Optimal Algorithm for
--   Prufer Codes", 2009
--   <a>https://www.scirp.org/pdf/JSEA20090200006_93737200.pdf</a></li>
--   </ul>
module Prufer

-- | Convert a bidirected Graph to a Prufer sequence. The graph must be a
--   connected tree or empty. O(n).
graphToSeq :: Graph -> [Vertex]

-- | Convert a Tree to a Prufer sequence. The tree must be rooted at r.
--   O(n).
treeToSeq :: Bounds -> Tree Vertex -> [Vertex]

-- | Convert a Prufer sequence to a list of edges, each edge present twice
--   in its two orientations. The sequence must be valid. O(n).
seqToEdges :: Bounds -> [Vertex] -> [Edge]

-- | Convert a Prufer sequence to a bidirected Graph. The sequence must be
--   valid. O(n).
seqToGraph :: Bounds -> [Vertex] -> Graph


-- | <h2>Segment tree</h2>
--   
--   A data structure supporting point updates and range queries on a
--   sequence of monoids. This implementation supports large ranges that do
--   not fit in memory, sometimes called a dynamic or sparse segment tree.
--   
--   Sources:
--   
--   <ul>
--   
--   <li><a>https://cp-algorithms.com/data_structures/segment_tree.html</a></li>
--   </ul>
--   
--   The complexities below assume mappend takes O(1) time. Let n = r - l +
--   1 in all instances below.
--   
--   SegTree implementable Foldable. Folding over all the elements takes
--   O(n).
module SegTree
data SegTree a

-- | Builds a segment tree on range (l, r) where each element is mempty.
--   O(log n).
emptyST :: Monoid a => (Int, Int) -> SegTree a

-- | Builds a segment tree on (l, r) where the elements are taken from a
--   list. If the list is shorter than the range, the remaining elements
--   are mempty. O(n).
fromListST :: Monoid a => (Int, Int) -> [a] -> SegTree a

-- | The bounds of the segment tree. O(1).
boundsST :: SegTree a -> (Int, Int)

-- | Adjusts the element at index i. O(log n).
adjustST :: Monoid a => (a -> a) -> Int -> SegTree a -> SegTree a

-- | Folds the elements in the range (ql, qr). Elements outside (l, r) are
--   considered to be mempty. O(log n).
foldRangeST :: Monoid a => Int -> Int -> SegTree a -> a
instance GHC.Show.Show a => GHC.Show.Show (SegTree.SegNode a)
instance GHC.Show.Show a => GHC.Show.Show (SegTree.SegTree a)
instance Data.Foldable.Foldable SegTree.SegTree
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (SegTree.SegTree a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (SegTree.SegNode a)


-- | <h2>Segment tree with lazy propagation</h2>
--   
--   A data structure supporting point updates, range queries, and certain
--   range updates on a sequence of monoids. This differs from an ordinary
--   segment tree in its ability to apply updates on a range, they are
--   otherwise identical. In fact, Segtree a can be defined as LazySegTree
--   () a. This implementation, like SegTree, supports large ranges that
--   may not fit in memory.
--   
--   Sources:
--   
--   <ul>
--   
--   <li><a>https://cp-algorithms.com/data_structures/segment_tree.html</a></li>
--   </ul>
--   
--   LazySegTree u a is a segment tree on elements of type a and updates of
--   type u. a and u must be monoids. An instance of Action u a must exist,
--   which specifies a (right) monoid action of u on a. The following laws
--   hold for a monoid action:
--   
--   <ul>
--   <li>(x <a>act</a> u1) <a>act</a> u2 = x <a>act</a> (u1 &lt;&gt;
--   u2)</li>
--   <li>x <a>act</a> mempty = x The segment tree requires an additional
--   law:</li>
--   <li>(x1 &lt;&gt; x2) <a>act</a> u = (x1 <a>act</a> u) &lt;&gt; (x2
--   <a>act</a> u)</li>
--   </ul>
--   
--   The complexities below assume &lt;&gt; for u, &lt;&gt; for a and act
--   all take O(1) time. Let n = r - l + 1 in all instances below.
module SegTreeLazy
data LazySegTree u a
class (Monoid u, Monoid a) => Action u a
act :: Action u a => a -> u -> a

-- | Builds a segment tree on range (l, r) where each element is mempty.
--   O(log n).
emptyLST :: Action u a => (Int, Int) -> LazySegTree u a

-- | Builds a segment tree on (l, r) where the elements are taken from a
--   list. If the list is shorter than the range, the remaining elements
--   are mempty. O(n).
fromListLST :: Action u a => (Int, Int) -> [a] -> LazySegTree u a

-- | The bounds of the segment tree. O(1).
boundsLST :: LazySegTree u a -> (Int, Int)

-- | Adjusts the element at index i. O(log n).
adjustLST :: Action u a => (a -> a) -> Int -> LazySegTree u a -> LazySegTree u a

-- | Applies an update on elements in the range (ql, qr). O(log n).
updateRangeLST :: Action u a => u -> Int -> Int -> LazySegTree u a -> LazySegTree u a

-- | Folds the elements in the range (ql, qr). Elements outside (l, r) are
--   considered to be mempty. O(log n).
foldRangeLST :: Action u a => Int -> Int -> LazySegTree u a -> a

-- | Right fold over the elements of the segment tree. O(n). LazySegTree u
--   cannot be Foldable because of the Action constraint :(
foldrLST :: Action u a => (a -> b -> b) -> b -> LazySegTree u a -> b
instance (GHC.Show.Show a, GHC.Show.Show u) => GHC.Show.Show (SegTreeLazy.LSegNode u a)
instance (GHC.Show.Show a, GHC.Show.Show u) => GHC.Show.Show (SegTreeLazy.LazySegTree u a)
instance (Control.DeepSeq.NFData u, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (SegTreeLazy.LazySegTree u a)
instance (Control.DeepSeq.NFData u, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (SegTreeLazy.LSegNode u a)


-- | <h2>Sorting</h2>
--   
--   Data.List.sort is rather inefficient when we don't care about laziness
--   and just want to fully sort a list. An in-place sort can have much
--   better performance. Benchmarks show that for a list of Ints, sort and
--   sortU are 4x and 8x faster than Data.List.sort.
--   
--   sort, sortBy, sortU, sortUBy use merge sort. countingSortUA uses
--   counting sort. Both are stable sorts.
--   
--   Sources:
--   
--   <ul>
--   <li><a>https://en.wikipedia.org/wiki/Merge_sort</a></li>
--   <li><a>https://en.wikipedia.org/wiki/Counting_sort</a></li>
--   </ul>
module Sort

-- | Sorts a list. O(n log n).
sort :: Ord e => [e] -> [e]

-- | Sorts a list with a comparison function. O(n log n).
sortBy :: (e -> e -> Ordering) -> [e] -> [e]

-- | Sorts a list for an element type that can be put in unboxed arrays.
--   Faster than sort. O(n log n).
sortU :: (Ord e, forall s. MArray (STUArray s) e (ST s), IArray UArray e) => [e] -> [e]

-- | Sorts a list for an element type that can be put in unboxed arrays
--   with a comparison function. Faster than sortBy. O(n log n).
sortUBy :: (forall s. MArray (STUArray s) e (ST s), IArray UArray e) => (e -> e -> Ordering) -> [e] -> [e]

-- | Sorts an unboxed array with a comparison function. O(n log n).
sortUABy :: (forall s. MArray (STUArray s) e (ST s), IArray UArray e) => (e -> e -> Ordering) -> UArray Int e -> UArray Int e

-- | Sorts an unboxed array using counting sort. f should be a function
--   that maps every element to an Int in [0..b-1]. O(n + b).
countingSortUA :: (IArray UArray e, forall s. MArray (STUArray s) e (ST s)) => Int -> (e -> Int) -> UArray Int e -> UArray Int e


-- | <h2>Kruskal's algorithm</h2>
--   
--   An algorithm to find the minimum spanning forest of an edge-weighted
--   graph.
--   
--   Sources:
--   
--   <ul>
--   <li><a>https://en.wikipedia.org/wiki/Kruskal%27s_algorithm</a></li>
--   <li>Joseph B. Kruskal, "On the shortest spanning subtree of a graph
--   and the traveling salesman problem", 1956
--   <a>https://www.ams.org/journals/proc/1956-007-01/S0002-9939-1956-0078686-7/</a></li>
--   </ul>
module Kruskal
data WEdge
WEdge :: !Vertex -> !Vertex -> !Weight -> WEdge
[getU] :: WEdge -> !Vertex
[getV] :: WEdge -> !Vertex
[getW] :: WEdge -> !Weight
type Weight = Int

-- | Runs Kruskal's algorithm on the graph represented by the given list of
--   edges. Returns the edges that are part of a minimum spanning forest.
--   Vertices should be non-negative. O(|V| + |E|log|E|).
kruskal :: Bounds -> [WEdge] -> [WEdge]
instance GHC.Show.Show Kruskal.WEdge
instance GHC.Classes.Eq Kruskal.WEdge
instance Control.DeepSeq.NFData Kruskal.WEdge


-- | <h2>Sparse table</h2>
--   
--   Structure for fast static range fold queries. Useful when the elements
--   do not form a group, otherwise prefix sums can be used.
--   
--   Sources:
--   
--   <ul>
--   
--   <li><a>https://cp-algorithms.com/data_structures/sparse-table.html</a></li>
--   
--   <li><a>https://github.com/kth-competitive-programming/kactl/blob/main/content/data-structures/RMQ.h</a></li>
--   </ul>
--   
--   Let n = r - l + 1 in all instances below.
module SparseTable

-- | Constructs a range fold function from a list. O(n log n) to construct
--   the structure and O(log n) for each query.
fromListSP :: Semigroup e => (Int, Int) -> [e] -> Int -> Int -> e

-- | Constructs a range fold function from a list, when the semigroup is
--   idempotent. O(n log n) to construct the structure and O(1) for each
--   query.
fromListISP :: Idempotent e => (Int, Int) -> [e] -> Int -> Int -> e

-- | Constructs a range fold function from a list. Uses an unboxed array.
--   O(n log n) to construct the structure and O(log n) for each query.
fromListUSP :: (IArray UArray e, forall s. MArray (STUArray s) e (ST s)) => (e -> e -> e) -> (Int, Int) -> [e] -> Int -> Int -> e

-- | Constructs a range fold function from a list, when the semigroup is
--   idempotent. Uses an unboxed array. O(n log n) to construct the
--   structure and O(1) for each query.
fromListIUSP :: (IArray UArray e, forall s. MArray (STUArray s) e (ST s)) => (e -> e -> e) -> (Int, Int) -> [e] -> Int -> Int -> e

-- | Builds a sparse table. O(n log n). Prefer the fromList functions.
buildSP :: MArray a e (ST s) => (e -> e -> e) -> (Int, Int) -> [e] -> ST s (a (Int, Int) e)

-- | Folds a range on a sparse table. O(log n). Prefer the fromList
--   functions.
foldSP :: IArray a e => (e -> e -> e) -> a (Int, Int) e -> Int -> Int -> e

-- | Folds a range on a sparse table, when the semigroup is idempotent.
--   O(1). Prefer the fromList functions.
foldISP :: IArray a e => (e -> e -> e) -> a (Int, Int) e -> Int -> Int -> e


-- | <h2>Lowest common ancestor queries on a tree</h2>
--   
--   Uses an Euler tour and a sparse table for range minimum queries, with
--   an range size optimization from 2n to n, adapted from PyRival.
--   
--   Sources:
--   
--   <ul>
--   <li><a>https://en.wikipedia.org/wiki/Lowest_common_ancestor</a></li>
--   <li>Michael Bender and Martin Farach-Colton, "The LCA Problem
--   Revisited", 2000
--   <a>https://www.ics.uci.edu/~eppstein/261/BenFar-LCA-00.pdf</a></li>
--   
--   <li><a>https://github.com/cheran-senthil/PyRival/blob/master/pyrival/graphs/lca.py</a></li>
--   </ul>
module LCA
data LCA

-- | Build a structure for LCA queries on a tree. O(n log n).
buildLCA :: Bounds -> Tree Vertex -> LCA

-- | Query the LCA of two nodes in a tree. O(1).
queryLCA :: Vertex -> Vertex -> LCA -> Vertex

-- | Build a structure for LCA queries on a forest. O(n log n).
build1LCA :: Bounds -> [Tree Vertex] -> LCA

-- | Query the LCA of two nodes in a forest. O(1).
query1LCA :: Vertex -> Vertex -> LCA -> Maybe Vertex
instance GHC.Show.Show LCA.LCA
instance Control.DeepSeq.NFData LCA.LCA


-- | <h2>Suffix array and LCP array</h2>
--   
--   A suffix array is the sorted array of all suffixes of a string, each
--   suffix represented by its start index. An LCP (longest common prefix)
--   array is an array of the lengths of the longest common prefixes of
--   consecutive suffixes in the suffix array. A suffix array, sometimes
--   with its LCP array, can be used to perform tasks like finding patterns
--   in the string or calculating certain properties of the string. Other
--   suffix structures, such as suffix trees and suffix automata may serve
--   as alternates to suffix arrays.
--   
--   This implementation constructs the suffix array and LCP array from a
--   given string indexing function, with elements of type Int. It takes
--   O(n log n), which is usually fast enough. O(n) algorithms to construct
--   suffix arrays exist.
--   
--   Sources:
--   
--   <ul>
--   <li>Udi Manber and Gene Myers, "Suffix Arrays: A New Method for
--   On-Line String Searches", 1990
--   <a>https://dl.acm.org/doi/10.5555/320176.320218</a></li>
--   <li>Kasai et al., "Linear-Time Longest-Common-Prefix Computation in
--   Suffix Arrays and Its Applications", 2001
--   <a>https://link.springer.com/chapter/10.1007/3-540-48194-X_17</a></li>
--   
--   <li><a>https://sites.google.com/site/indy256/algo/suffix_array</a></li>
--   </ul>
module SuffixArray
type Chr = Int
type SuffixId = Int

-- | Builds a suffix array and LCP array. n is the length of the string. at
--   is a 0-based indexing function into the string. Characters must be in
--   [0..b-1]. Faster than buildSufAL unless b is too large. O(b + n log
--   n).
buildSufA :: Chr -> Int -> (Int -> Chr) -> (UArray Int SuffixId, UArray Int Int)

-- | Builds a suffix array and LCP array. n is the length of the string. at
--   is a 0-based indexing function into the string. Intended for large
--   alphabets. O(n log n).
buildSufAL :: Int -> (Int -> Chr) -> (UArray Int SuffixId, UArray Int Int)


-- | <h2>Draw trees</h2>
--   
--   Primarily intended for debugging.
module TreeDraw

-- | Draws a tree. Like Data.Tree.drawTree but works with any type, can
--   show edge labels and uses unicode box characters. Example: a ├── 1 ──
--   b ├── 2 ── c │ ├── d │ └── e └── 3 ── f
draw :: (a -> String) -> (a -> [(Maybe String, a)]) -> a -> String


-- | <h2>Suffix tree</h2>
--   
--   A moderately simple and flexible suffix tree. A suffix tree of a
--   string is a compressed trie of all the suffixes of the string, useful
--   for fast matching on substrings of the string or to calculate certain
--   properties of the string. Other suffix structures such as suffix
--   arrays and suffix automata may serve as alternates to suffix trees.
--   
--   The implementation here constructs a SuffixTree a from a given string
--   index function, with string elements of type Int. Ukkonen's algorithm
--   is used for construction. This is not lazy, the entire tree is
--   constructed right away. Only the implicit suffix tree is constructed,
--   which is a suffix tree where suffixes that are prefixes of other
--   suffixes do not end in leaves. To make them end in leaves, set the
--   last element of the string to a unique value. A SuffixTree a also
--   stores accumulated values of type a at every node. These values are
--   calculated using user supplied functions, which can be chosen based on
--   what the tree will be used for.
--   
--   Sources:
--   
--   <ul>
--   <li>Esko Ukkonen, "On–line construction of suffix trees", 1995
--   <a>https://www.cs.helsinki.fi/u/ukkonen/SuffixT1withFigs.pdf</a></li>
--   <li>Dan Gusfield, "Algorithms on Strings, Trees, and Sequences", 1997
--   <a>https://doi.org/10.1017/CBO9780511574931</a></li>
--   </ul>
--   
--   String indexing is assumed to take O(1). Let k be the alphabet size.
--   Let the complexity of IntMap operations be f(n), where n is the size
--   of the map. f(n) is O(min(n, word size)), see IntMap documentation for
--   details.
module SuffixTree
data SufTNode a
SufTNode :: !a -> !IntMap (SufTEdge a) -> SufTNode a
data SufTEdge a
SufTEdge :: !Int -> !Int -> !SufTNode a -> SufTEdge a
type Chr = Int

-- | Builds a suffix tree. n is the length of the string. at is a 0-based
--   indexing function into the string. fromLeaf constructs a value from a
--   leaf index. updEdge constructs a value from an existing value and a
--   length of an edge leading to it. merge combines two values. Examples:
--   To query the number of times a pattern occurs in the string, use const
--   1, const, and (+). To calculate the number of distinct substrings, use
--   const 0, (+), and (+). O(n * f(k)), plus the above functions are each
--   called O(n) times.
buildSufT :: (Int -> a) -> (a -> Int -> a) -> (a -> a -> a) -> Int -> (Int -> Chr) -> SufTNode a

-- | Matches a pattern on the suffix tree. updEdge and at are as defined
--   for buildSufT. m is the length of the pattern. at' is a 0-based
--   indexing function into the pattern. If the pattern is not present,
--   returns Nothing. Otherwise returns the accumulated value for the
--   subtree where the pattern ends. O(m * f(k)) plus at most one call of
--   updEdge.
matchSufT :: (a -> Int -> a) -> (Int -> Chr) -> SufTNode a -> Int -> (Int -> Chr) -> Maybe a

-- | buildSufT together with matchSufT to avoid having to repeat arguments.
--   Apply partially for multiple queries.
buildMatchSufT :: (Int -> a) -> (a -> Int -> a) -> (a -> a -> a) -> Int -> (Int -> Chr) -> Int -> (Int -> Chr) -> Maybe a

-- | Draws a suffix tree. Can be used for debugging.
drawSufT :: Show a => SufTNode a -> String
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (SuffixTree.SufTEdge a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (SuffixTree.SufTNode a)


-- | <h2>2-satisfiability</h2>
--   
--   Solves the 2-sat problem, which assigns boolean values to variables
--   (a, b, c...) such that it satisfies a boolean expression which is a
--   conjunction of clauses, where each clause is a disjunction of two
--   variables. For example, (a || b) &amp;&amp; (a || not c) &amp;&amp;
--   (not b || not c). The solution is obtained from the strongly connected
--   components of the implication graph constructed from the clauses.
--   
--   Sources:
--   
--   <ul>
--   <li><a>https://en.wikipedia.org/wiki/2-satisfiability</a></li>
--   <li><a>https://cp-algorithms.com/graph/2SAT.html</a></li>
--   </ul>
module TwoSat
data Var
Id :: !Int -> Var
Not :: !Int -> Var

-- | Solves the 2-sat problem where each variable is represented by an Int
--   in the range (l, r). Returns a list of assignments for the variables l
--   to r, in order. O(n + m) where n = r - l + 1 and m = length xys.
solve2Sat :: (Int, Int) -> [(Var, Var)] -> Maybe [Bool]
instance GHC.Show.Show TwoSat.Var
instance Control.DeepSeq.NFData TwoSat.Var


-- | <h2>Z-function</h2>
--   
--   A string matching algorithm. The Z-algorithm generates the function z
--   from a string s, where z(i) is the length of the longest prefix of s
--   that starts at i. z[0] is set to 0.
--   
--   Sources:
--   
--   <ul>
--   <li><a>https://cp-algorithms.com/string/z-function.html</a></li>
--   </ul>
module ZFunc

-- | Constructs the Z-function. The input sequence should be 0-indexed.
--   O(n).
zFunc :: Eq a => Int -> (Int -> a) -> UArray Int Int

-- | zFunc for a ByteString. O(n).
zFuncBS :: ByteString -> UArray Int Int
