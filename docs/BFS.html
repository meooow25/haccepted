<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>BFS</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">haccepted-0.1.0.0: Data structures and algorithms</span><ul class="links" id="page-menu"><li><a href="src/BFS.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">BFS</p></div><div id="description"><p class="caption">Description</p><div class="doc"><h2>Breadth first search</h2><p>Sources:</p><ul><li><a href="https://en.wikipedia.org/wiki/Breadth-first_search">https://en.wikipedia.org/wiki/Breadth-first_search</a></li></ul></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:bfs">bfs</a> :: <a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Graph.html#t:Graph" title="Data.Graph">Graph</a> -&gt; [<a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Graph.html#t:Vertex" title="Data.Graph">Vertex</a>] -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> <a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Graph.html#t:Vertex" title="Data.Graph">Vertex</a></li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:bfs" class="def">bfs</a> :: <a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Graph.html#t:Graph" title="Data.Graph">Graph</a> -&gt; [<a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Graph.html#t:Vertex" title="Data.Graph">Vertex</a>] -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> <a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Graph.html#t:Vertex" title="Data.Graph">Vertex</a> <a href="src/BFS.html#bfs" class="link">Source</a> <a href="#v:bfs" class="selflink">#</a></p><div class="doc"><p>BFS on a graph, starting from the given source vertices. One tree per source is returned, which
 contains all the vertices reached from the source before they could be reached by another.
 Note that this is unlike Data.Graph.dfs, which returns one Tree for each connected component.
 O(n + m), for a graph with n vertices and m edges.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.0</p></div></body></html>